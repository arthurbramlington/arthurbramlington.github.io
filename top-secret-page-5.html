<html>
  <head>
    <script src="libs/lightweight-charts.standalone.production.js"></script>
		<script src="utilities.js"></script>
  </head>
  <body>
    <h1>Liam's top secret page 5</h1>
    <h2>buying on the underside of an MA line</h2>

  <pre>
    fetch("https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1d&limit=1000").then(x => x.json()).then(x => {
      	var pc = (a, b) => {
  	    if (a === b) return 0; // avoid any floating point crazyness
  	    return (100 - (b / (a / 100))) * -1;
  	}
      class MovAvg {
      	    constructor(interval) {
      	        this.interval = interval;
      	        this.priceHistory = [];
      	        this.valueHistory = [];
      	    }
      
      	    addNewPrice(price) {
      	        this.priceHistory.push(price);
      	        if (this.priceHistory.length < this.interval) return;
      	        const slicedRange = this.priceHistory.slice(this.priceHistory.length - this.interval, this.priceHistory.length);
      	        const currentAvg = slicedRange.reduce((a, cv) => a + cv) / slicedRange.length
      	        this.valueHistory.push(currentAvg);
      	    }
      
      	    mostRecentValue(num = 1) {
      	        if (num > this.valueHistory.length) {
      	            return this.valueHistory;
      	        }
      	        const lastIndex = this.valueHistory.length;
      	        return this.valueHistory.slice(lastIndex - num, lastIndex);
      	    }
      
      	    mostRecentChange() {
      	        if (this.valueHistory < 2) return 0;
      	        const r = this.mostRecentValue(2);
      	        return pc(r[0], r[1]);
      	    }
      	}
      
      var openPositions = []; // buyPrice, sellAt
      var buyAmount = 10;
      var takeProfit = 10;
      var fees = 0.2;
      var movingAverageNumber = 50;
      var mA = new MovAvg(movingAverageNumber);
      var sellCount = 0;
      var biggestPositionCount = 0;
      
      x.map((candle) => {
          var openPrice = parseFloat(candle[1]);
          var highPrice = parseFloat(candle[2]);
          mA.addNewPrice(openPrice);
          if(!mA.mostRecentValue()) return;
          if(openPrice < mA.mostRecentValue()) {
              openPositions.push({
                  buyPrice: openPrice,
                  sellAt: openPrice * ((100 + takeProfit) / 100)
              })
          }
          openPositions.length && openPositions.map((p, i) => {
              if(p.sellAt <= highPrice) {
                  sellCount++;
                  openPositions.splice(i, 1)
              }
          });
          if(openPositions.length > biggestPositionCount) {
              biggestPositionCount = openPositions.length;
          }
      });
      
      var mostRecentClose = parseFloat(x[x.length - 1][4]);
      console.log(`biggestPositionCount: ${biggestPositionCount}`);
      console.log(`Profit: ${((takeProfit/100) * buyAmount) * sellCount}`);
      console.log(`currentOpenPosition P&L: ${( openPositions.reduce((a,c) => a + pc(c.buyPrice, mostRecentClose), 0) ) / openPositions.length}`);
    })
  </pre>
</html>
