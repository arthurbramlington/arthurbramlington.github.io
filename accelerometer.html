<html>
<body style="padding: 100px;">
	<head>
		<link rel="stylesheet" href="styles.css">
	</head>
<script>

	// U T I L  F U N C S
	var pc = (a, b) => {
	    if (a === b) return 0; // avoid any floating point crazyness
	    return (100 - (b / (a / 100))) * -1;
	}
	var changeByXPercent = (targ, perc) => (((perc / 100) + 1) * targ);
	var avcan = (array, includeCurrentCandle = false, onlyUpperRange = false) => {
	    const lowIndex = onlyUpperRange ? 1 : 3;
	    const ranges = array.map(c => {
	        return pc(parseFloat(c[lowIndex]), parseFloat(c[2]))
	    });
	    const rangesNew = includeCurrentCandle ? ranges : ranges.slice(0, ranges.length - 1);
	    return rangesNew.reduce((a, b) => a + b, 0) / ranges.length
	}

	class MovAvg {
	    constructor(interval) {
	        this.interval = interval;
	        this.priceHistory = [];
	        this.valueHistory = [];
	    }

	    addNewPrice(price) {
	        this.priceHistory.push(price);
	        if (this.priceHistory.length < this.interval) return;
	        const slicedRange = this.priceHistory.slice(this.priceHistory.length - this.interval, this.priceHistory.length);
	        const currentAvg = slicedRange.reduce((a, cv) => a + cv) / slicedRange.length
	        this.valueHistory.push(currentAvg);
	    }

	    mostRecentValue(num = 1) {
	        if (num > this.valueHistory.length) {
	            return this.valueHistory;
	        }
	        const lastIndex = this.valueHistory.length;
	        return this.valueHistory.slice(lastIndex - num, lastIndex);
	    }

	    mostRecentChange() {
	        if (this.valueHistory < 2) return 0;
	        const r = this.mostRecentValue(2);
	        return pc(r[0], r[1]);
	    }
	}
	/* U T I L   F U N C S   E N D */

	const popupToggle = () => popup.classList.toggle('hide');

	const getCandleComparison = (candles, includeWick = false) => {
	    const range = includeWick ? {a: 2, b: 3}: {a: 1, b: 4};
	    const currentCandle = candles.slice(-1)[0];
	    const remainingCandles = candles.slice(0, candles.length - 1);
	    const currentCandleChange = Math.abs(parseFloat(currentCandle[range.a]) - parseFloat(currentCandle[range.b]));
	    const totalChange = remainingCandles.reduce((accumulator, candle) => accumulator + Math.abs(parseFloat(candle[range.a]) - parseFloat(candle[range.b])), 0)
	    const recentCandlesAverage = totalChange / remainingCandles.length;
	    const recentCandlesAverageAsPercent = pc(parseFloat(currentCandle[1]), parseFloat(currentCandle[1]) + recentCandlesAverage); // NOTE: using currentCandle[1] as an approx current price, this is lazy, change it at some point. This whole function could be using percent rather than the price difference if that's easier.
	    const currentCandleMultiplier = !currentCandleChange || !recentCandlesAverage ? 0 : currentCandleChange / recentCandlesAverage;
	    return {recentCandlesAverageAsPercent, currentCandleMultiplier};
	}

	const historicLog = (analPeriod, symbol, candleCount) => {
		return fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${analPeriod}&limit=1000`)
			.then(data => data.json())
			.then(candleHistory => {
			    const historyWithScore = candleHistory.map((candle, index) => {
			        if ((index - candleCount) < 0) {
			            return [];
			        }
			        const indexSliceAdjusted = index + 1;
			        const candleHistorySnippet = candleHistory.slice(indexSliceAdjusted - candleCount, indexSliceAdjusted)
			        return {
			            datestampOpen: candle[0],
			            ...getCandleComparison(candleHistorySnippet)
			        }
			    })
			    return historyWithScore;
			}).catch(e => {
				console.log(e.message)
				return [];
			})
	}

	const candleSizeColourDecider = (sizePercent) => {
		// this is very crude but fuck it. Currently these are modeled on the 15m candles, but they should of course vary. Also just randomly chosen hahahahah
		if(sizePercent < 0.2) {
			return " override red";
		} else if (sizePercent < 0.8) {
			return " override amber";
		} else if (sizePercent < 1.3) {
			return " override green";
		} else {
			return " override white-hot";
		}
	}

	const getAndShowHistoricLog = async (analPeriod, symbol, candleCount) => {
		popupToggle();
		const theHistoricLog = await historicLog(analPeriod, symbol, candleCount);
		console.log(theHistoricLog.map(n => (`${new Date(n.datestampOpen)} - ${n.currentCandleMultiplier}`)));
		popupContent.innerHTML = "<ul id='historicalAccelerometerList'></ul>";
		historicalAccelerometerList.innerHTML = theHistoricLog.map(n => {
		    if (n.length === 0) return;
		    return `
		        <li>
		            <span class="symbol">
		                ${new Date(n.datestampOpen).toString().substring(0,24)}
		            </span>
		            </div><div class="TURBO-indicator">
						<span class='bead-light ${candleSizeColourDecider(n.recentCandlesAverageAsPercent)}'></span>
					</div>
		            <span class="recent-percentages">
		                ${(n.recentCandlesAverageAsPercent).toString().substring(0, 4)}% <small>(rctavg)</small>
		            </span>
		            <span class="multiplier">
		                ${(n.currentCandleMultiplier).toString().substring(0, 4)}
		            </span>
		            <div class="TURBO-indicator">
		                ${[...Array(Math.ceil(n.currentCandleMultiplier))].map(() => "<span class='bead-light'></span>").join('')}
		            </div>
		        </li>
		    `
		}).join("");
	}

	var getTopMovers = () => {
		const candleCount = parseInt(timeframeSelector.value);
		const candleInterval = candleIntervalSelector.value;
		fetch('https://api.binance.com/api/v3/exchangeInfo').then(data => data.json()).then((i) => {
			var usdtList = i.symbols.filter((p) => p.quoteAsset === "USDT" && p.status === "TRADING")
			Promise.all(usdtList.map((p) => {
				return fetch(`https://api.binance.com/api/v3/klines?symbol=${p.symbol}&interval=${candleInterval}&limit=${candleCount}`).then(data => data.json()).then(candles => ({pair: p, candles})).catch(e => console.log(e.message))
			})).then((values) => {
				window.allCandles = values;
				const withMultiplierValue = values.map(item => {
					return {
						...item,
						...getCandleComparison(item.candles)
					}
				});
				const withMultiplierValueSorted = withMultiplierValue.sort((a,b) => b.currentCandleMultiplier - a.currentCandleMultiplier);
				console.log("V A L U E S :  ", values, "W I T H   M U L T I P L I E R :  ", withMultiplierValueSorted);
			    topMovers.innerHTML = withMultiplierValueSorted.map(n => `
			    	<li id="${n.pair.symbol}">
			    		<span class="symbol" onclick="getAndShowHistoricLog(\'${candleInterval}\', \'${n.pair.symbol}\', \'${candleCount}\')">
			    			${n.pair.symbol}
			    		</span>
						</div><div class="TURBO-indicator">
							<span class='bead-light ${candleSizeColourDecider(n.recentCandlesAverageAsPercent)}'></span>
						</div>
			    		<span class="recent-percentages">
			    			${(n.recentCandlesAverageAsPercent).toString().substring(0, 4)}% <small>(rctavg)</small>
			    		</span>
			    		<span class="multiplier">
			    			${(n.currentCandleMultiplier).toString().substring(0, 4)}
			    		</span>
						<div class="TURBO-indicator">
							${[...Array(Math.ceil(n.currentCandleMultiplier))].map(() => "<span class='bead-light'></span>").join('')}
			    	</li>
			    `).join('');
			});
		}).catch(e => console.log(e.message));
	}
</script>
<div id="popup" class="hide">
	<div id="popupClose" onclick="popupToggle()">X</div>
	<div id="popupContent"></div>
</div>
<nav>
	<a href="index.html">H O M E</a>
</nav>
<h1>Accelerometer</h1>

<hr />
<strong>To-do</strong>
<ul>
	<li>I'VE JUST REALISED in the very common case where you've had a massive candle and are halfway through the next this tool will be impeded since the recent average has gone up and it will also be delayed in noting the recent increase because it's starting from 0 on the new candle open point. I suppose this is corrected by using a higher candle period though.</li>
	<li>select number of recent candles for the average</li>
	<li>which candle time frame to use</li>
	<li>include wick or not - actually, give both by default</li>
	<li>give a simple reading of how many times the recent average this candle is.</li>
	<li>volume data? I'm not convinced how relevant this is at this point</li>
	<li>audio alerts with interval selector</li>
	<li>some form of analysis of a longer range of candles MA performance</li>
	<li>A way of filtering out those crappy little candles where very little or nothing has happened. Possibly a user-selected bullshit threshold. Ignore charts with those candles or ignore the candles themselves?</li>
	<li>V V V V  O P T I O N A L  V V V V</li>
	<li>Inculde most recent candle percent</li>
	<li>Option to compare current open/close with recent candle's full range</li>
</ul>
<hr />

<h2>Top accelerators</h2>
<input id="timeframeSelector" type="number" value="15" />
<label>candle count</label>
<br />
<input id="candleIntervalSelector" type="input" value="15m" />
<label>candle interval (e.g. 1m, 1h, 4h, 1d etc...)</label>
<br />
<button onclick="getTopMovers()">Launch</button>
<ol id="topMovers" class="top-accelerators-list"></ol>
</body>

</html>
