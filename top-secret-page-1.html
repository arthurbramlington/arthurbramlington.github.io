<html>
  <body>
    <h1>Liam's top secret page 1</h1>
    <h2>Never sell</h2>
    <p>I seem to remember the idea is to buy periodically and only sell at a profit, otherwise holding forever. Have a read through.</p>
    <label>fetch URL</label>
    <input id="IfetchUrl" type="text" style="width: 600px;" value="https://api.binance.com/api/v3/klines?symbol=BLZUSDT&interval=4h&limit=1000" />
    <br />
    <label>positions limit</label>
    <input id="IpositionsLimit" type="number" value="10" />
    <br />
    <label>buy interval</label>
    <input id="IbuyInterval" type="number" value="10" />
    <br />
    <label>take profit(%)</label>
    <input id="ItakeProfit" type="number" value="5" />
    <br />
    <label>fees</label>
    <input id="Ifees" type="number" value="0.2" />
    <br />
    <button onclick="bangaroo()">bangaroo</button>
    <br />
    <div id="logZone"></div>
    <script>
      var pc = (a, b) => {
          if (a === b) return 0; // avoid any floating point crazyness
          return (100 - (b / (a / 100))) * -1;
      }

      var log = (content) => {
        console.log(content);
        var x = document.createElement("div")
        x.innerHTML = content
        logZone.append(x);
      };
      var clearLog = () => {
        logZone.innerHTML = "";
      };
      
      var bangaroo = () => {
        fetch(IfetchUrl.value).then(d => d.json()).then(data => {
            clearLog();
          
            var buyInterval = parseInt(IbuyInterval.value);
            var positionsLimit = parseInt(IpositionsLimit.value);
            var positions = [];
            var takeProfit = parseFloat(ItakeProfit.value); // should be with a recent candle size or such, but this is just a quick prototype
            var fees = parseFloat(Ifees.value);
            var pot = 0;

            data.map((candle, index) => {
                log('<br />');
                log(`/ / / / / / / (#${index}) ${new Date(candle[0]).toISOString().slice(0,10)} / / / / / / / `);
                const positionLimitReached = (positions.length === positionsLimit);
                if(index % buyInterval === 0) {
                    if(positionLimitReached) {
                        log("Cannot buy, positions limit reached.");
                    }else {
                        // buy time baby
                        log('Creating position.');
                        positions.push({
                            buyPrice: parseFloat(candle[1]),
                            buyTime: candle[0],
                        });
                    }
                }
                // do the accounts
                positions.map((position, positionIndex) => {
                    if(pc(position.buyPrice, candle[2]) >= takeProfit) {
                        log('SOLD');
                        pot += (takeProfit - fees)
                        positions.splice(positionIndex, 1);
                    }
                })
                // keep a log of p&l
                const debt = positions.reduce((a, p) => a + pc(p.buyPrice, candle[3]), 0);
                const total = pot + debt;
                log("pot: " + pot);
                log("debt: " + debt);
                log(`total: ${(total < 0 ? '<span style="color: red;">' : '<span style="color: green;">')}${total}</span>`);
                log(!positions.length ? "No positions open." : positions.map(p => pc(p.buyPrice, candle[3])));
            });  
        })
      }
    </script>
  </body>
</html>
