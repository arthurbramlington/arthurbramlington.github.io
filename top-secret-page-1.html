<html>
  <head>
    <script src="libs/lightweight-charts.standalone.production.js"></script>
		<script src="utilities.js"></script>
  </head>
  <body>
    <h1>Liam's top secret page 1</h1>
    <h2>Never sell</h2>
    <p>I seem to remember the idea is to buy periodically and only sell at a profit, otherwise holding forever. Have a read through.</p>
    <h3>Sideways movers of interest:</h3>
    <ul>
      <li>ASR</li>
      <li>UFT</li>
      <li>TRB</li>
    </ul>
    <p>Also see the diary notes from 13/03/24</p>
    <p>AEUR is an interesting one, I wonder if it's going to explode one day. It's so newly listed and so sideways. So high-volume but also not volitile. It's worth reading up on. I can't see it on binance though.</p>
    <label>fetch URL</label>
    <input id="IfetchUrl" type="text" style="width: 600px;" value="https://api.binance.com/api/v3/klines?symbol=JASMYUSDT&interval=1d&limit=1000" />
    <br />
    <label>positions size</label>
    <input id="IpositionsSize" type="number" value="1" />
    <br />
    <label>positions limit</label>
    <input id="IpositionsLimit" type="number" value="9999" />
    <br />
    <label>buy interval</label>
    <input id="IbuyInterval" type="number" value="7" />
    <br />
    <label>take profit(%)</label>
    <input id="ItakeProfit" type="number" value="10" />
    <br />
    <label>fees</label>
    <input id="Ifees" type="number" value="0.2" />
    <br />
    <button onclick="bangaroo()">bangaroo</button>
    <br />
    <div id="theChart"></div>
    <br />
    <div id="logZone"></div>
    <script>
      var log = (content) => {
        console.log(content);
        var x = document.createElement("div")
        x.innerHTML = content
        logZone.append(x);
      };
      var clearLog = () => {
        logZone.innerHTML = "";
      };
      
      var bangaroo = () => {
        fetch(IfetchUrl.value).then(d => d.json()).then(data => {
            clearLog();
          
            var buyInterval = parseInt(IbuyInterval.value);
            var positionsLimit = parseInt(IpositionsLimit.value);
            var positionsSize = parseInt(IpositionsSize.value);
            var positions = [];
            var closeCount = 0;
            var takeProfit = parseFloat(ItakeProfit.value); // should be with a recent candle size or such, but this is just a quick prototype
            var fees = parseFloat(Ifees.value);
            var closedProfit = 0;

            // trading view chart variables
            var lineData = [];

            data.map((candle, index) => {
                log('<br />');
                log(`/ / / / / / / (#${index}) ${new Date(candle[0]).toISOString().slice(0,10)} / / / / / / / `);
                const positionLimitReached = (positions.length === positionsLimit);
                if(index % buyInterval === 0) {
                    if(positionLimitReached) {
                        log("Cannot buy, positions limit reached.");
                    }else {
                        // buy time baby
                        log('Creating position.');
                        positions.push({
                            buyPrice: parseFloat(candle[1]),
                            buyTime: candle[0],
                        });
                    }
                }
                // do the accounts
                positions.map((position, positionIndex) => {
                    if(pc(position.buyPrice, candle[2]) >= takeProfit) {
                        log('SOLD');
                        closeCount++;
                        closedProfit += ((positionsSize * (((takeProfit - fees)/100) + 1)) - positionsSize);
                        positions.splice(positionIndex, 1);
                    }
                })
                // keep a log of p&l
                const usdtSpentOnOpenPositions = positions.length * positionsSize;
                const openProfitAndLossPercent = positions.reduce((a, p) => a + pc(p.buyPrice, candle[3]), 0)/positions.length;
                const usdtValueOfOpenPositions = usdtSpentOnOpenPositions * ((100 + openProfitAndLossPercent) / 100);
                const openProfitAndLossUsdt = (usdtValueOfOpenPositions - usdtSpentOnOpenPositions);
                const total = closedProfit + (positions.length ? openProfitAndLossUsdt : 0);
                log("closedProfit: " + closedProfit);
                log("closeCount: " + closeCount);
                log("openProfitAndLossPercent: " + openProfitAndLossPercent);
                log("usdtSpentOnOpenPositions: " + usdtSpentOnOpenPositions);
                log("usdtValueOfOpenPositions: " + usdtValueOfOpenPositions);
                log("openProfitAndLossUsdt: " + openProfitAndLossUsdt);
                log(`balance USDT: ${(total < 0 ? '<span style="color: red;">' : '<span style="color: green;">')}${total}</span>`);
                log(!positions.length ? "No positions open." : positions.map(p => `${pc(p.buyPrice, candle[3]).toFixed(2)}%`).join(', '));

                // trading view chart data
                lineData.push({time: candle[0]/1000, value: openProfitAndLossUsdt});
            });
            drawChart(null, null, null, lineData, null, "theChart");
        })
      }
      // NOTE: this is all more complicated than I'd considered since you're logging the amount
      // 'invested' and a percentage gained or lost in money terms and percentage terms.

      // tradingview charts test
      const singleCandle = [1637539200000,"0.14510000","0.36490000","0.14510000","0.23660000","938176313.60000000",1637625599999,"222029894.54801000",551758,"454479631.20000000","107405995.74771000","0"];
      var singleData = [{
        time: singleCandle[0]/1000,
        open: parseFloat(singleCandle[1]),
        high: parseFloat(singleCandle[2]),
        low: parseFloat(singleCandle[3]),
        close: parseFloat(singleCandle[4])
      }]
      drawChart(singleData,null,null,null,null,'theChart')
    </script>
  </body>
</html>
