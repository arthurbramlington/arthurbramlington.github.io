<html>
  <body>
    <h1>Liam's top secret page 1</h1>
    <h2>Never sell</h2>
    <p>I seem to remember the idea is to buy periodically and only sell at a profit, otherwise holding forever. Have a read through.</p>
    <label>fetch URL</label>
    <input id="IfetchUrl" type="text" value="https://api.binance.com/api/v3/klines?symbol=BLZUSDT&interval=4h&limit=1000" />
    <br />
    <label>positions limit</label>
    <input id="IpositionsLimit" type="number" value="10" />
    <br />
    <label>take profit(%)</label>
    <input id="ItakeProfit" type="number" value="5" />
    <br />
    <label>fees</label>
    <input id="Ifees" type="number" value="0.2" />
    <br />
    <button onclick="bangaroo()">bangaroo</button>
    <br />
    <div id="logZone"></div>
    <button onclick="() => logZone.innerHTML = ''">clear</button>
    <script>
      var pc = (a, b) => {
          if (a === b) return 0; // avoid any floating point crazyness
          return (100 - (b / (a / 100))) * -1;
      }

      var bangaroo = () => {
        fetch(IfetchUrl.value).then(d => d.json()).then(data => {
            var buyInterval = 10;
            var positionsLimit = IpositionsLimit;
            var positions = [];
            var takeProfit = ItakeProfit.value; // should be with a recent candle size or such, but this is just a quick prototype
            var fees = Ifees.value;
            var pot = 0;
        
            var log = (content) => {
              console.log(content);
              logZone.innerHTML = logZone.innerHTML + "content"
              // document.write(content);
              // document.write("<br />");
            };
        
            data.map((candle, index) => {
                log('    ');
                log(`/ / / / / / / candle ${index} / / / / / / / `);
                const positionLimitReached = (positions.length === positionsLimit);
                if(index % buyInterval === 0) {
                    if(positionLimitReached) {
                        log("Cannot buy, positions limit reached.");
                    }else {
                        // buy time baby
                        log('Creating position.');
                        positions.push({
                            buyPrice: parseFloat(candle[1]),
                            buyTime: candle[0],
                        });
                    }
                }
                // do the accounts
                positions.map((position, positionIndex) => {
                    if(pc(position.buyPrice, candle[2]) >= takeProfit) {
                        log('SOLD');
                        pot += (takeProfit - fees)
                        positions.splice(positionIndex, 1);
                    }
                })
                // keep a log of p&l
                log("pot: " + pot);
                log("debt: " + positions.reduce((a, p) => a + pc(p.buyPrice, candle[3]), 0));
                log(!positions.length ? "No positions open." : positions.map(p => pc(p.buyPrice, candle[3])));
            });  
        })
      }
    </script>
  </body>
</html>
