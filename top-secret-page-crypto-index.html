<html>
  <head>
    <link rel="stylesheet" href="styles.css">
    <script src="libs/lightweight-charts.standalone.production.js"></script>
    <script src="utilities.js"></script>
    <style>
      .day-wrap {
        width: 100%;
        overflow-x: scroll;
        display: flex;
        border: 10px solid #06181f;
        border-radius: 10px;
        padding: 10px;
      }
      .day-block {
        min-width: 260px;
      }
    </style>
  </head>
  <body style="padding: 100px;">

    <h1>Uncle Liam's Dip Finder</h1>
    <h2>Thoughts:</h2>
    <ul>
      <li>Ooo what would happen if you buy when something enters the top 20 and sell when it either leaves the top 10 (or the top 20 having never made it to the top 10).</li>
      <li>Or a combination of criteria like sell at +3% or when it leaves the top X</li>
      <li>Something might surge like mad, but by the time it leaves the top X it's back where it started. Can't you make a sell trigger into its value losing a certain percentage after entering the top X? So any time it loses a quater of it's max gain since entering the top X. For example if it's gone up to +40% profit from your buy-in and now it's at +30% you sell. this would have to be above a certain number because the difference between 40% and 30% is very different in behavioral terms from 4% to 3%</li>
      <li>what if you gave it specific scapling buy and sell instructions once it enters the top X - it would be hard to know which sell condition was hit first though.</li>
      <li>Factor in market cap or volume? Maybe the ones that have a lot of weight behind them linger for longer.</li>
      <li>How about an option to only buy coins that have previously been in the top 20, thus potentially filtering for major spikers to some extent.</li>
      <li>I wonder if there's merit in waiting for a coin with a sufficient market cap / lending pool to enter the mix and then shorting it.</li>
      <li>Try setting it to 1d, 1 day rating period and top 100, it seems to be exclusively bad. I wonder if you could mass-short</li>
      <li>Anything you buy can only go down by 100%, but it can go up infinitely. Is this an arguement for buying anyhing that's performed more than 0? Or maybe even ignoreing the price performance entirely and just buying anything that's had market cap growth.</li>
    </ul>

    <h1>NOTE: try it with 1w - everything breaks and it shouldn't.</h1>

    <h1>NOTE: also, the buy and sell transactions aren't always equal, they should be, there should always be 10 holdings at a time.</h1>

<form onsubmit="getTheDippers();return false;">
  <input id="candleIntervalSelector" value="1d" />
  <label for="candleIntervalSelector">Interval</label>

  <br />
  
  <input id="ratingPeriodSelector" value="1" />
  <label for="ratingPeriodSelector">Rating Period (how many units of the interval to look back and see the best performers)</label>

  <br />
  
  <input id="topXSelector" value="10" />
  <label for="topXSelector">Select the top X (e.g. top 5, 10, 20)</label>

  <br />

  <button>Fetch</button>
</form>

    <button onclick="processTheData()">Calculate without fetching (interval will be the same)</button>

    <div id="loadingSpinner"></div>

    <div id="resultsArea" class="day-wrap"></div>

    <script>

      window.candleCount = 1000;
      window.holdings = [];
      window.transactions = [];

    	const getTheDippers = async () => {
    		loadingSpinner.classList.add('spinner');
    		const candleInterval = candleIntervalSelector.value;
    		await fetch('https://api.binance.com/api/v3/exchangeInfo').then(data => data.json()).then(async (i) => {
    			var usdtList = i.symbols.filter((p) => p.quoteAsset === "USDT" && p.status === "TRADING")
    			await Promise.all(usdtList.map((p) => {
    				return fetch(`https://api.binance.com/api/v3/klines?symbol=${p.symbol}&interval=${candleInterval}&limit=${window.candleCount}`).then(data => data.json()).then(candles => ({pair: p, candles: candles.slice(0, candles.length)})).catch(e => console.log(e.message))
    			})).then((values) => {
            window.allCandles = values;
            processTheData();
            loadingSpinner.classList.remove('spinner');
    			});
    		}).catch(e => console.log("ERROR in getTheDippers: " + e.message));
    		loadingSpinner.classList.remove('spinner');
    		return "FINISHED";
    	}

      var processTheData = () => {
        window.holdings = [];
        window.transactions = [];
        const ratingPeriod = parseInt(ratingPeriodSelector.value);
        const topX = parseInt(topXSelector.value);
        
        if(!window.allCandles) {
          alert('fetch first u knobhead');
        };

        // make a day by day log of all the top performers
        
        window.eachDayPerformanceChart = [];
        
        for(var day = 0; day < window.candleCount; day++) { // I'm just writing this as if the interval is a day since it's easier to think of it like that.
            window.eachDayPerformanceChart[day] = [];
            if(day < ratingPeriod) continue;
        
            const performanceListUnsorted = [];
            
            window.allCandles.map(coinData => {
                const candles = coinData.candles;
                const comparisonDayIndex = day - ratingPeriod;
                if(candles[comparisonDayIndex] && candles[day]) {
                    //console.log(`At this time: ${new Date(candles[day][0])}, the pair ${coinData.pair.symbol} had a change of ${pc(candles[comparisonDayIndex][1], candles[day][1])}%`);
                    performanceListUnsorted.push({
                        symbol: coinData.pair.symbol,
                        change: pc(candles[comparisonDayIndex][1], candles[day][1]),
                        openPrice: parseFloat(candles[day][1]),
                        // fullCandle: candles[day]
                    });
                }
            });
            
            window.eachDayPerformanceChart[day] = performanceListUnsorted.sort((a, b) => b.change - a.change);

            // update holdings and transactions
            const todaysTopX = window.eachDayPerformanceChart[day].slice(0, topX);
            const convertToHoldingsFormat = (arr) => {
                return arr.map(n => ({
                    symbol: n.symbol,
                    buyPrice: n.openPrice
                }))
            }
            if(!window.holdings.length) {
                window.holdings = convertToHoldingsFormat(todaysTopX);
            }else {
                const buySell = {buy: [], sell: []};
                window.holdings.map((h, i) => {
                    const isOut = todaysTopX.findIndex(ttx => ttx.symbol === h.symbol) === -1;
                    if(isOut) {
                        const currentPrice = window.eachDayPerformanceChart[day].find(n => n.symbol === h.symbol); // get it's current price
                        buySell.sell.push({...h, currentPrice: currentPrice?.openPrice});
                        window.holdings.splice(i, 1);
                    }
                });
                todaysTopX.map(ttx => {
                    const isIn = window.holdings.findIndex(h => h.symbol === ttx.symbol) === -1;
                    if(isIn) {
                        buySell.buy.push(ttx);
                        window.holdings.push(convertToHoldingsFormat([ttx])[0]);
                    }
                });
                window.transactions[day] = buySell;
                // if you want to boost persformace you could just have eachDayPerformanceChart be the same as todaysTopX, the only reason they are seperate is if I want to see what's outside of the top X
            }
        }
        
        drawTimeUnitScroller();
      }

      var drawTimeUnitScroller = () => {
        const topX = parseInt(topXSelector.value);
        const nodeList = [];
          resultsArea.innerHTML = "";
          window.eachDayPerformanceChart.map((day, index) => {
              const dayBlock = document.createElement("div");
              dayBlock.setAttribute("class", "day-block");
              dayBlock.setAttribute("id", "dayBlock_"+index);
              if(!day.length) {
                  dayBlock.appendChild(document.createTextNode(`No comparison possible`));
                  nodeList.push(dayBlock);
                  return;
              };
              day.map((coin, coinIndex) => {
                  if(coinIndex > 20) return; // otherwise there's just waaaay too much data
                dayBlock.appendChild(document.createTextNode(`${coin.symbol}, ${coin.change.toFixed(2)}%, ${coin.openPrice.toFixed(4)}`));
                  dayBlock.appendChild(document.createElement("br"));
                  if(coinIndex === (topX - 1)) {
                    dayBlock.appendChild(document.createElement("hr"));
                  }
              })
              nodeList.push(dayBlock);
          })
          resultsArea.append(...nodeList);
      }
    
    </script>
  </body>

</html>
