<html>
  <head>
    <link rel="stylesheet" href="styles.css">
    <script src="libs/lightweight-charts.standalone.production.js"></script>
    <script src="utilities.js"></script>
    <style>
      .day-wrap {
        width: 100%;
        overflow-x: scroll;
        display: flex;
        border: 10px solid #06181f;
        border-radius: 10px;
        padding: 10px;
      }
      .day-block {
        min-width: 260px;
      }
    </style>
  </head>
  <body style="padding: 100px;">

    <h1>Uncle Liam's Dip Finder</h1>

<form onsubmit="getTheDippers();return false;">
  <input id="candleIntervalSelector" value="1h" />
  <label for="candleIntervalSelector">Interval</label>

  <br />
  
  <input id="ratingPeriodSelector" value="12" />
  <label for="ratingPeriodSelector">Rating Period (how many units of the interval to look back and see the best performers)</label>

  <br />
  
  <input id="topXSelector" value="10" />
  <label for="topXSelector">Select the top X (e.g. top 5, 10, 20)</label>

  <br />

  <button>Fetch</button>
</form>

    <button onclick="processTheData()">Calculate without fetching (interval will be the same)</button>

    <div id="loadingSpinner"></div>

    <div id="resultsArea" class="day-wrap"></div>

    <script>

      window.candleCount = 1000;
      window.holdings = [];
      window.transactions = [];

    	const getTheDippers = async () => {
    		loadingSpinner.classList.add('spinner');
    		const candleInterval = candleIntervalSelector.value;
    		await fetch('https://api.binance.com/api/v3/exchangeInfo').then(data => data.json()).then(async (i) => {
    			var usdtList = i.symbols.filter((p) => p.quoteAsset === "USDT" && p.status === "TRADING")
    			await Promise.all(usdtList.map((p) => {
    				return fetch(`https://api.binance.com/api/v3/klines?symbol=${p.symbol}&interval=${candleInterval}&limit=${window.candleCount}`).then(data => data.json()).then(candles => ({pair: p, candles: candles.slice(0, candles.length)})).catch(e => console.log(e.message))
    			})).then((values) => {
            window.allCandles = values;
            processTheData();
            loadingSpinner.classList.remove('spinner');
    			});
    		}).catch(e => console.log("ERROR in getTheDippers: " + e.message));
    		loadingSpinner.classList.remove('spinner');
    		return "FINISHED";
    	}

      var processTheData = () => {
        window.holdings = [];
        window.transactions = [];
        const ratingPeriod = parseInt(ratingPeriodSelector.value);
        const topX = parseInt(topXSelector.value);
        
        if(!window.allCandles) {
          alert('fetch first u knobhead');
        };

        // make a day by day log of all the top performers
        
        window.eachDayPerformanceChart = [];
        
        for(var day = 0; day < window.candleCount; day++) { // I'm just writing this as if the interval is a day since it's easier to think of it like that.
            window.eachDayPerformanceChart[day] = [];
            if(day < ratingPeriod) continue;
        
            const performanceListUnsorted = [];
            
            window.allCandles.map(coinData => {
                const candles = coinData.candles;
                const comparisonDayIndex = day - ratingPeriod;
                if(candles[comparisonDayIndex] && candles[day]) {
                    //console.log(`At this time: ${new Date(candles[day][0])}, the pair ${coinData.pair.symbol} had a change of ${pc(candles[comparisonDayIndex][1], candles[day][1])}%`);
                    performanceListUnsorted.push({
                        symbol: coinData.pair.symbol,
                        change: pc(candles[comparisonDayIndex][1], candles[day][1]),
                        openPrice: candles[day][1],
                        fullCandle: candles[day]
                    });
                }
            });
            
            window.eachDayPerformanceChart[day] = performanceListUnsorted.sort((a, b) => b.change - a.change);

            const todaysTopX = window.eachDayPerformanceChart[day].slice(0, topX);
            if(!window.holdings.length) {
                window.holdings = todaysTopX;
            }else {
                const outOfTheTopX = window.holdings.filter(h => todaysTopX.findIndex(ttx => ttx.symbol === h.symbol) === -1);
                window.transactions[day] = outOfTheTopX;
                // if you want to boost persformace you could just have eachDayPerformanceChart be the same as todaysTopX, the only reason they are seperate is if I want to see what's outside of the top X
                window.holdings = todaysTopX;
            }
        }
        
        drawTimeUnitScroller();
      }

      var drawTimeUnitScroller = () => {
        const topX = parseInt(topXSelector.value);
        const nodeList = [];
          resultsArea.innerHTML = "";
          window.eachDayPerformanceChart.map((day, index) => {
              const dayBlock = document.createElement("div");
              dayBlock.setAttribute("class", "day-block");
              dayBlock.setAttribute("id", "dayBlock_"+index);
              if(!day.length) {
                  dayBlock.appendChild(document.createTextNode(`No comparison possible`));
                  nodeList.push(dayBlock);
                  return;
              };
              day.map((coin, coinIndex) => {
                  if(coinIndex > 20) return; // otherwise there's just waaaay too much data
                dayBlock.appendChild(document.createTextNode(`${coin.symbol}, ${coin.change.toFixed(2)}%, ${parseFloat(coin.openPrice).toFixed(4)}`));
                  dayBlock.appendChild(document.createElement("br"));
                  if(coinIndex > topX) {
                    dayBlock.appendChild(document.createElement("hr"));
                  }
              })
              nodeList.push(dayBlock);
          })
          resultsArea.append(...nodeList);
      }
    
    </script>
  </body>

</html>
