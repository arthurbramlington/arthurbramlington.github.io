<html>
<body style="padding: 100px;">
	<head>
		<link rel="stylesheet" href="styles.css">
		<script src="libs/lightweight-charts.standalone.production.js"></script>
		<script src="utilities.js"></script>
	</head>
<script>
	// W I N D O W  V A R S
	window.fetchList = {};
	// W I N D O W  V A R S  E N D

	const popupToggle = () => popup.classList.toggle('hide');

	const simulate = (fetchData) => {
		var smaLine = new MovAvg(parseInt(userInput_smaLength.value));
		var smaLineSecond = new MovAvg(parseInt(userInput_secondSma.value));
	    var sellAfter = parseInt(userInput_sellAfter.value); // including the first candle where the guy happened
	    var fees = parseFloat(userInput_fees.value);
	    var smaPercentChangeLowerLimit = userInput_smaPercentChangeLowerLimit.value;
	    var averageCandleSizeMinimum = parseFloat(userInput_averageCandleSizeMinimum.value);
	    var averageCandleRange = parseInt(userInput_averageCandleRange.value);
	    var pot = 0;
	    var firstOpenedAbove = [];
	    var soldLog = [];
	    var lastBuyPrice = null;
	    var lastBuyIndex = null;
	    var chartMarkers = [];
	    var chartVolume = [];
	    var chartSma = [];
	    var chartSmaSecond = [];

	    const settle = (buyPrice, sellPrice, candle) => {
	    	// NOTE: this returns the loss or gain from this one trade, not the running total
	    	const lossOrGain = pc(buyPrice, sellPrice) - fees;
	    	pot += lossOrGain;
	    	soldLog.push({lossOrGain, potAtTimeOfSale: JSON.stringify(pot), candle})
	    	return lossOrGain;
	    }

	    const chartCandleFormatter = (candle, buyOrSell, additionalInformation) => {
            if(buyOrSell === "buy") {
				chartMarkers.push({
					time: candle[0]/1000,
					position: 'aboveBar',
					color: 'rgba(0,0,200,1)',
					shape: 'arrowDown',
					text: `B${additionalInformation ? ' ' + additionalInformation : ''}`,
				});
            } else if(buyOrSell === "sell") {
				chartMarkers.push({
					time: candle[0]/1000,
					position: 'aboveBar',
					color: additionalInformation >= 0 ? 'rgba(0,200,0,1)' : 'rgba(200,0,0,1)',
					shape: 'arrowDown',
					text: `S${additionalInformation ? ' ' + additionalInformation : ''}`,
				});
            }
            return {
	            time: candle[0]/1000,
	            open: parseFloat(candle[1]),
	            high: parseFloat(candle[2]),
	            low: parseFloat(candle[3]),
	            close: parseFloat(candle[4])
            };
	    }
	    const dataInChartFormat = fetchData.map((candle, index) => {

	        smaLine.addNewPrice(parseFloat(candle[4]));
	        smaLineSecond.addNewPrice(parseFloat(candle[4]));
	    	chartVolume.push({time: candle[0]/1000, value: parseFloat(candle[7])});
	    	
	    	const smaMostRecentValue = smaLine.mostRecentValue();
	    	if(smaMostRecentValue) {
	    		chartSma.push({time: candle[0]/1000, value: smaMostRecentValue});	    		
	    	}
	    	const smaSecondMostRecentValue = smaLineSecond.mostRecentValue();
	    	if(smaSecondMostRecentValue) {
	    		chartSmaSecond.push({time: candle[0]/1000, value: smaSecondMostRecentValue});	    		
	    	}

	        if(index === 0) return chartCandleFormatter(candle);
	        if(lastBuyPrice) {
	            if (index === lastBuyIndex + sellAfter) {
	            	const settledLossOrGain = settle(lastBuyPrice, parseFloat(candle[4]), candle);
	                lastBuyPrice = null;
	                lastBuyIndex = null;
	                return chartCandleFormatter(candle, "sell", settledLossOrGain.toFixed(2));
	            };
	            return chartCandleFormatter(candle);
	        }
	        if(
	        	parseFloat(candle[1]) > smaLine.mostRecentValue() 
	        	&& parseFloat(fetchData[index - 1][1]) <= smaLine.mostRecentValue() 
	        	&& smaLine.mostRecentChange() > smaPercentChangeLowerLimit
	        	&& averageCandleSize(fetchData.slice(index - averageCandleRange, index)) >= averageCandleSizeMinimum
	        ){
	            if(sellAfter === 0) {
	            	const settledLossOrGain = settle(parseFloat(candle[1]), parseFloat(candle[4]), candle)
	                lastBuyPrice = null;
	                lastBuyIndex = null;
	                return chartCandleFormatter(candle, "sell", settledLossOrGain.toFixed(2));
	            }
	            lastBuyPrice = parseFloat(candle[1]);
	            lastBuyIndex = index;
	            firstOpenedAbove.push(candle);
	            return chartCandleFormatter(candle, "buy");
	        }
	        return chartCandleFormatter(candle);
	    });
	    console.log('soldLog ', soldLog)
	    resultsLog.innerHTML = "<h3>Log:</h3>" + soldLog.map(n => `${new Date(n.candle[0]).toLocaleString()} / <span style="color: ${n.lossOrGain >= 0 ? "green" : "red"}">${n.lossOrGain.toFixed(2)}%</span> / running P&L: ${n.potAtTimeOfSale}`).join('<br>');
	    resultsOverview.innerHTML = `<h3>gain/loss: ${pot.toFixed(2)}% over ${firstOpenedAbove.length} buys</h3>`;
	    chartSmaSecond = userInput_secondSmaCheckbox.checked ? chartSmaSecond : null;
	    drawChart(dataInChartFormat, chartMarkers, chartVolume, chartSma, chartSmaSecond); // this needs to add buy and sell points onto the chart with profit/loss and fees
	}

	const drawChart = (chartData, markers, volumeData, smaData, smaSecondData) => {
		//https://tradingview.github.io/lightweight-charts/docs/api/interfaces/ISeriesApi
		//https://tradingview.github.io/lightweight-charts/docs/api/interfaces/CandlestickData
		theChart.innerHTML = "";

		// chart config
		var chart = LightweightCharts.createChart("theChart", {
		    width: 1400,
		    height: 700,
		    layout: {
		        background: {
		            type: 'solid',
		            color: '#000000',
		        },
		        textColor: 'rgba(0, 155, 0, 0.75)',
		    },
		    grid: {
		        vertLines: {
		            color: 'rgba(0, 155, 0, 0.25)',
		        },
		        horzLines: {
		            color: 'rgba(0, 155, 0, 0.25)',
		        },
		    },
		    crosshair: {
		        mode: LightweightCharts.CrosshairMode.Normal,
		    },
		    rightPriceScale: {
		        borderColor: 'rgba(197, 203, 206, 0.8)',
		    },
		    timeScale: {
		        borderColor: 'rgba(197, 203, 206, 0.8)',
		        timeVisible: true,
		    },
		});

		// condlestick series
		var candleSeries = chart.addCandlestickSeries({
			upColor: 'rgba(0, 155, 0, 1)',
			downColor: 'rgba(155, 0, 0, 1)',
			borderDownColor: 'rgba(155, 0, 0, 0.5)',
			borderUpColor: 'rgba(0, 155, 0, 0.5)',
			wickDownColor: 'rgba(155, 0, 0, 1)',
			wickUpColor: 'rgba(0, 155, 0, 1)',
		});

		candleSeries.setData(chartData);
		candleSeries.setMarkers(markers);

		// volume series
		const volumeSeries = chart.addHistogramSeries({
			color: '#26a69a',
			priceFormat: {
				type: 'volume',
			},
			priceScaleId: '', // set as an overlay by setting a blank priceScaleId
			// set the positioning of the volume series
			scaleMargins: {
				top: 0.7, // highest point of the series will be 70% away from the top
				bottom: 0,
			},
		});
		volumeSeries.priceScale().applyOptions({
			scaleMargins: {
				top: 0.7, // highest point of the series will be 70% away from the top
				bottom: 0,
			},
		})
		volumeSeries.setData(volumeData);

		// SMA series
		const smaSeries = chart.addLineSeries({
			color: '#2962FF',
			lineWidth: 2,
			// disabling built-in price lines
			lastValueVisible: false,
			priceLineVisible: false,
		});
		smaSeries.setData(smaData);

		// SMA optional second series
		if(smaSecondData) {
			const smaSecondSeries = chart.addLineSeries({
				color: 'orange',
				lineWidth: 2,
				// disabling built-in price lines
				lastValueVisible: false,
				priceLineVisible: false,
			});
			smaSecondSeries.setData(smaSecondData);
		}

		chart.timeScale().fitContent();
	}

	const run = async () => {
		loadingSpinner.classList.add('spinner');
		errorMessage.innerHTML = "";
		try{
			const fetchUrl = `https://api.binance.com/api/v3/klines?symbol=${userInput_symbol.value.toUpperCase()}&interval=${userInput_candleInterval.value}&limit=1000`
			if(!!window.fetchList[fetchUrl]) { // caching
				simulate(window.fetchList[fetchUrl]);
			} else {
				await fetch(fetchUrl).then(raw => raw.json()).then(fetchData => {
			    	simulate(fetchData);
			    	window.fetchList[fetchUrl] = fetchData;
				})
			}
		} catch (error) {
  			console.error('Error in run()', error);
  			errorMessage.innerHTML = error;
		}
		loadingSpinner.classList.remove('spinner');
		return "FINISHED";
	}

</script>
<div id="popup" class="hide">
	<div id="popupClose" onclick="popupToggle()">X</div>
	<div id="popupContent"></div>
</div>
<nav>
	<a href="index.html">H O M E</a>
	<span> / </span>
	<a href="accelerometer.html">A C C E L E R O M E T E R</a>
	<span> / </span>
	<a href="top-moving-averages.html">S M O O T H  G A I N E R Z</a>
	<span> / </span>
	<a href="cross-alerter.html">C R O S S  A L E R T E R</a>
	<span> / </span>
	<a href="buy-over-sma.html.html">B U Y  O V E R  S M A</a>
</nav>
<h1>Buy Over SMA Line</h1>

<hr />
<strong>To-do</strong>
<ul>
	<li>Try/catch error logging for user too and exit run() func</li>
	<li>capitalise the symbol in run()</li>
	<li>REALLY needs a limit to the period you're analysing, this isn't something you would run non stop on any chart.</li>
	<li>Add a "plug-pull" point, where you might automatically sell if the loss gets too much</li>
	<li>recent average candle should a different interval and count if the user requires.</li>
	<li>seeing the candle dates would be great</li>
	<li>cache with fetch string</li>
	<li>needs neutral or positive MA stipulation</li>
	<li>needs a list of the top recent avg candles</li>
	<li>add time limit for cache</li>
	<li>Add a stipulation to how far it needs to have dipped below the MA before coming back above?</li>
	<li>CLEARLY MAKES GOOD MONEY ON POSITIVE CHARTS HUH? MAYBe it's worth having a positive 200MA (or longer) stipulation</li>
</ul>
<hr />
<h2>Buy Over SMA Line</h2>
<input id="userInput_symbol" type="input" value="BTCUSDT" />
<label>Symbol</label>
<br />
<input id="userInput_candleInterval" type="input" value="5m" />
<label>candle interval (e.g. 1m, 1h, 4h, 1d etc...)</label>
<br />
<input id="userInput_fees" type="input" value="0.2" />
<label>Trading fees</label>
<br />
<input id="userInput_smaLength" type="number" value="50" />
<label>SMA length</label>
<br />
<input id="userInput_smaPercentChangeLowerLimit" type="number" value="0.03" />
<label>SMA percent change lower limit (0 is a flat line)</label>
<br />
<input id="userInput_sellAfter" type="input" value="3" />
<label>candles to sell after</label>
<br />
<hr />
<input id="userInput_averageCandleSizeMinimum" type="input" value="0.2" />
<label>Only buy when average candle size is >= (%)</label>
<br />
<input id="userInput_averageCandleRange" type="input" value="45" />
<label>Average candle range</label>
<br />
<hr />
<input id="userInput_secondSmaCheckbox" type="checkbox" onchange="userInput_secondSmaWrap.classList.toggle('hide');"/>
<label>Draw second SMA</label>
<br />
<span class="hide" id="userInput_secondSmaWrap">
<input id="userInput_secondSma" type="input" value="200" />
<label>Second SMA length</label>
</span>
<br />
<div id="launchSection">
	<button onclick="run()">Launch</button>
</div>

<div id="loadingSpinner"></div>
<div id="errorMessage"></div>

<div id="resultsOverview"></div>
<div id="theChart"></div>
<div id="resultsLog"></div>

</body>

</html>
