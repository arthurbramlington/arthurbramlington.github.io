<html>
<body style="padding: 100px;">
	<head>
		<link rel="stylesheet" href="styles.css">
		<script src="https://code.highcharts.com/stock/highstock.js"></script>
		<script src="https://code.highcharts.com/stock/modules/exporting.js"></script>
		<script src="https://code.highcharts.com/stock/modules/accessibility.js"></script>
		<script src="https://code.highcharts.com/stock/indicators/indicators.js"></script>
		<script src="utilities.js"></script>
	</head>
<script>
	// W I N D O W  V A R S
	window.fetchList = {};
	// W I N D O W  V A R S  E N D

	// set Highcharts timezone
	Highcharts.setOptions({
	    time: {
	        timezoneOffset: new Date().getTimezoneOffset()
	    }
	});

	const popupToggle = () => popup.classList.toggle('hide');

	const simulate = (fetchData) => {
		var smaLine = new MovAvg(parseInt(userInput_smaLength.value));
	    var sellAfter = parseInt(userInput_sellAfter.value); // including the first candle where the guy happened
	    var fees = parseFloat(userInput_fees.value);
	    var smaPercentChangeLowerLimit = userInput_smaPercentChangeLowerLimit.value;
	    var averageCandleSizeMinimum = parseFloat(userInput_averageCandleSizeMinimum.value);
	    var averageCandleRange = parseInt(userInput_averageCandleRange.value);
	    var pot = 0;
	    var firstOpenedAbove = [];
	    var soldLog = [];
	    var lastBuyPrice = null;
	    var lastBuyIndex = null;

	    const settle = (buyPrice, sellPrice, candle) => {
	    	// NOTE: this returns the loss or gain from this one trade, not the running total
	    	const lossOrGain = pc(buyPrice, sellPrice) - fees;
	    	pot += lossOrGain;
	    	soldLog.push({lossOrGain, potAtTimeOfSale: JSON.stringify(pot), candle})
	    	return lossOrGain;
	    }

	    const highChartCandleFormatter = (candle, buyOrSell, additionalInformation) => {
            var returnObj = {
	            x: candle[0],
	            open: parseFloat(candle[1]),
	            high: parseFloat(candle[2]),
	            low: parseFloat(candle[3]),
	            close: parseFloat(candle[4])
            }
            if(buyOrSell === "buy") {
				returnObj["dataLabels"] = {
					enabled: true,
					format: 'B',
					y: 10,
					color: "green"
				}
            } else if(buyOrSell === "sell") {
				returnObj["dataLabels"] = {
					enabled: true,
					format: `S ${additionalInformation}`,
					y: 10,
					color: "red"
				}
            }
            return returnObj;
	    }
	    const fetchDataHighchartFormat =  fetchData.map((candle, index) => {
	        smaLine.addNewPrice(parseFloat(candle[4]));
	        if(index === 0) return highChartCandleFormatter(candle);
	        if(lastBuyPrice) {
	            if (index === lastBuyIndex + sellAfter) {
	            	const settledLossOrGain = settle(lastBuyPrice, parseFloat(candle[4]), candle);
	                lastBuyPrice = null;
	                lastBuyIndex = null;
	                return highChartCandleFormatter(candle, "sell", settledLossOrGain.toFixed(2));
	            };
	            return highChartCandleFormatter(candle);
	        }
	        if(
	        	parseFloat(candle[1]) > smaLine.mostRecentValue() 
	        	&& parseFloat(fetchData[index - 1][1]) <= smaLine.mostRecentValue() 
	        	&& smaLine.mostRecentChange() > smaPercentChangeLowerLimit
	        	&& averageCandleSize(fetchData.slice(index - averageCandleRange, index)) >= averageCandleSizeMinimum
	        ){
	            if(sellAfter === 0) {
	            	const settledLossOrGain = settle(parseFloat(candle[1]), parseFloat(candle[4]), candle)
	                lastBuyPrice = null;
	                lastBuyIndex = null;
	                return highChartCandleFormatter(candle, "sell", settledLossOrGain.toFixed(2));
	            }
	            lastBuyPrice = parseFloat(candle[4]);
	            lastBuyIndex = index;
	            firstOpenedAbove.push(candle);
	            return highChartCandleFormatter(candle, "buy");
	        }
	        return highChartCandleFormatter(candle);
	    });
	    console.log('soldLog ', soldLog)
	    resultsLog.innerHTML = "<h3>Log:</h3>" + soldLog.map(n => `${new Date(n.candle[0]).toGMTString()} / ${n.lossOrGain.toFixed(2)}% / running P&L: ${n.potAtTimeOfSale}`).join('<br>');
	    resultsOverview.innerHTML = `<h3>gain/loss: ${pot.toFixed(2)}% over ${firstOpenedAbove.length} buys</h3>`;
	    drawChart(fetchDataHighchartFormat); // this needs to add buy and sell points onto the chart with profit/loss and fees
	}

	const drawChart = (fetchDataHighchartFormat) => {
		// FYI https://api.highcharts.com/highstock/series.candlestick.data
		Highcharts.stockChart("theChart", {
			rangeSelector: {
				selected: 1
			},
			title: {
				text: `${userInput_symbol.value.toUpperCase()}`
			},
			series: [
				{
					type: 'candlestick',
					id: "penis",
					data: fetchDataHighchartFormat
				},
				{
					type: 'sma',
					linkedTo: "penis",
					params: {
						period: parseInt(userInput_smaLength.value)
					},
					color: "orange",
					marker: {
						enabled: false
					}
				}
			],
			chart: {
				backgroundColor: "rgba(0,0,0,1)",
			},
			yAxis: {
				gridLineColor: 'rgba(0,255,0,0.5)',
			},
			plotOptions: {
				candlestick: {
					color: '#ef5351',
					upColor: '#26a79a'
				}
			}
		});
	}

	const run = async () => {
		loadingSpinner.classList.add('spinner');
		errorMessage.innerHTML = "";
		try{
			const fetchUrl = `https://api.binance.com/api/v3/klines?symbol=${userInput_symbol.value.toUpperCase()}&interval=${userInput_candleInterval.value}&limit=1000`
			if(!!window.fetchList[fetchUrl]) { // caching
				simulate(window.fetchList[fetchUrl]);
			} else {
				await fetch(fetchUrl).then(raw => raw.json()).then(fetchData => {
			    	simulate(fetchData);
			    	window.fetchList[fetchUrl] = fetchData;
				})
			}
		} catch (error) {
  			console.error('Error in run()', error);
  			errorMessage.innerHTML = error;
		}
		loadingSpinner.classList.remove('spinner');
		return "FINISHED";
	}

</script>
<div id="popup" class="hide">
	<div id="popupClose" onclick="popupToggle()">X</div>
	<div id="popupContent"></div>
</div>
<nav>
	<a href="index.html">H O M E</a>
	<span> / </span>
	<a href="accelerometer.html">A C C E L E R O M E T E R</a>
	<span> / </span>
	<a href="top-moving-averages.html">S M O O T H  G A I N E R Z</a>
	<span> / </span>
	<a href="cross-alerter.html">C R O S S  A L E R T E R</a>
	<span> / </span>
	<a href="buy-over-sma.html.html">B U Y  O V E R  S M A</a>
</nav>
<h1>Buy Over SMA Line</h1>

<hr />
<strong>To-do</strong>
<ul>
	<li>Try/catch error logging for user too and exit run() func</li>
	<li>capitalise the symbol in run()</li>
	<li>REALLY needs a limit to the period you're analysing, this isn't something you would run non stop on any chart.</li>
	<li>Add a "plug-pull" point, where you might automatically sell if the loss gets too much</li>
	<li>recent average candle should a different interval and count if the user requires.</li>
	<li>seeing the candle dates would be great</li>
	<li>cache with fetch string</li>
	<li>needs neutral or positive MA stipulation</li>
	<li>needs a list of the top recent avg candles</li>
	<li>add time limit for cache</li>
	<li>Add a stipulation to how far it needs to have dipped below the MA before coming back above?</li>
	<li>CLEARLY MAKES GOOD MONEY ON POSITIVE CHARTS HUH? MAYBe it's worth having a positive 200MA (or longer) stipulation</li>
</ul>
<hr />
<h2>Buy Over SMA Line</h2>
<input id="userInput_symbol" type="input" value="BTCUSDT" />
<label>Symbol</label>
<br />
<input id="userInput_candleInterval" type="input" value="5m" />
<label>candle interval (e.g. 1m, 1h, 4h, 1d etc...)</label>
<br />
<input id="userInput_fees" type="input" value="0.2" />
<label>Trading fees</label>
<br />
<input id="userInput_smaLength" type="number" value="50" />
<label>SMA length</label>
<br />
<input id="userInput_smaPercentChangeLowerLimit" type="number" value="0" />
<label>SMA percent change lower limit (0 is a flat line)</label>
<br />
<input id="userInput_sellAfter" type="input" value="3" />
<label>candles to sell after</label>
<br />
<hr />
<input id="userInput_averageCandleSizeMinimum" type="input" value="0.2" />
<label>Only buy when average candle size is >= (%)</label>
<br />
<input id="userInput_averageCandleRange" type="input" value="45" />
<label>Average candle range</label>
<br />
<div id="launchSection">
	<button onclick="run()">Launch</button>
</div>

<div id="loadingSpinner"></div>
<div id="errorMessage"></div>

<div id="resultsOverview"></div>
<div id="theChart"></div>
<div id="resultsLog"></div>

</body>

</html>
